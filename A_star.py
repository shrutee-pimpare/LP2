"""AI-2(A*).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x8A9bX9uWj-HTk3aIuvESdCFBghthT_u
"""

import heapq

def astar(start, goal, graph):
    # Initialize the open and closed lists
    open_list = [(0, start)]
    closed_list = set()

    # Initialize the path and cost dictionaries
    path = {start: None}
    cost = {start: 0}

    while open_list:
        # Get the node with the lowest cost from the open list
        current_cost, current_node = heapq.heappop(open_list)

        # Add the current node to the closed list
        closed_list.add(current_node)

        # Check if the goal node has been reached
        if current_node == goal:
            return reconstruct_path(path, start, goal)

        # Explore the neighbors of the current node
        for neighbor, weight in graph[current_node].items():
            # Calculate the tentative cost from the start node to the neighbor node
            tentative_cost = cost[current_node] + weight

            # Check if the neighbor node is already in the closed list
            if neighbor in closed_list:
                continue

            # Check if the neighbor node is not in the open list or has a lower cost
            if neighbor not in [node for _, node in open_list] or tentative_cost < cost[neighbor]:
                # Update the path and cost dictionaries
                path[neighbor] = current_node
                cost[neighbor] = tentative_cost

                # Calculate the heuristic value for the neighbor node
                heuristic_value = heuristic(neighbor, goal)

                # Add the neighbor node to the open list with the combined cost and heuristic value
                heapq.heappush(open_list, (tentative_cost + heuristic_value, neighbor))

    # No path found
    return None

def reconstruct_path(path, start, goal):
    # Reconstruct the shortest path from the goal node to the start node
    current_node = goal
    path_nodes = []

    while current_node != start:
        path_nodes.append(current_node)
        current_node = path[current_node]

    # Add the start node to the path
    path_nodes.append(start)

    # Reverse the path to get the correct order
    path_nodes.reverse()

    return path_nodes

def heuristic(node, goal):
    # Calculate the Manhattan distance as the heuristic
    return abs(ord(node) - ord(goal))

# Function to input the graph from the user
def get_graph_from_user():
    graph = {}

    num_edges = int(input("Enter the number of edges: "))

    for _ in range(num_edges):
        source = input("Enter the source node: ")
        target = input("Enter the target node: ")
        weight = int(input("Enter the weight: "))

        # Add the edge to the graph
        if source not in graph:
            graph[source] = {}
        graph[source][target] = weight

    return graph

# Example usage
graph = get_graph_from_user()

start_node = input("Enter the start node: ")
goal_node = input("Enter the goal node: ")
shortest_path = astar(start_node, goal_node, graph)

if shortest_path is None:
    print("No path found.")
else:
    print("Shortest path:", ' -> '.join(shortest_path))